using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;

using Adobe.Substance.Input;
using Adobe.SubstanceEditor.Importer;
using Adobe.SubstanceEditor.ProjectSettings;
using Adobe.Substance;

namespace Adobe.SubstanceEditor
{
    /// <summary>
    /// Editor Singleton to manage interactions with the Substance engine.
    /// </summary>
    internal sealed class SubstanceEditorEngine : ScriptableSingleton<SubstanceEditorEngine>
    {
        /// <summary>
        /// Substance files currently loaded in the engine.
        /// </summary>
        private readonly Dictionary<string, SubstanceNativeHandler> _activeSubstanceDictionary = new Dictionary<string, SubstanceNativeHandler>();

        /// <summary>
        /// Currently active instances.
        /// </summary>
        private readonly List<SubstanceGraphSO> _managedInstances = new List<SubstanceGraphSO>();

        private readonly Queue<string> _delayiedInitilization = new Queue<string>();

        /// <summary>
        /// Render results generated by the substance engine in a background thread.
        /// </summary>
        private readonly ConcurrentQueue<RenderResult> _renderResultsQueue = new ConcurrentQueue<RenderResult>();

        private readonly List<SubstanceGraphSO> _playmodeObjects = new List<SubstanceGraphSO>();

        private bool _resetAllInputs = false;

        /// <summary>
        /// Initializer to ensure SubstanceEditorEngine is
        /// started consistently on editor load and assembly reload.
        ///</summary>
        [InitializeOnLoad]
        private sealed class SubstanceEditorEngineInitializer
        {
            static SubstanceEditorEngineInitializer()
            {
                AssemblyReloadEvents.beforeAssemblyReload += OnBeforeAssemblyReload;
                AssemblyReloadEvents.afterAssemblyReload += OnAfterAssemblyReload;
            }

            private static void OnBeforeAssemblyReload()
            {
                SubstanceEditorEngine.instance.TearDown();
            }

            private static void OnAfterAssemblyReload()
            {
                SubstanceEditorEngine.instance.Setup();
            }
        }

        private bool _isLoaded;

        public bool IsInitialized => _isLoaded;

        /// <summary>
        /// Initalize substance engine.
        /// </summary>
        private void Setup()
        {
            _isLoaded = false;
            PluginPipelines.GetCurrentPipelineInUse();
            var enginePath = PlatformUtils.GetEnginePath();
            var pluginPath = PlatformUtils.GetPluginPath();
            Engine.Initialize(pluginPath, enginePath);
            EditorApplication.update += Update;
            Undo.undoRedoPerformed += UndoCallback;
        }

        private void UndoCallback()
        {
            if (Selection.activeObject is SubstanceGraphSO)
            {
                var target = Selection.activeObject as SubstanceGraphSO;

                var managedInstance = _managedInstances.FirstOrDefault((a) => a.GUID == target.GUID);

                if (managedInstance != null)
                {
                    managedInstance.RenderTextures = true;
                    PushAllInputsToUpdate();
                }
            }
        }

        /// <summary>
        /// Shutdown substance engine.
        /// </summary>
        private void TearDown()
        {
            _isLoaded = false;
            EditorApplication.update -= Update;
            Undo.undoRedoPerformed -= UndoCallback;
            Engine.Shutdown();
        }

        #region Update

        /// <summary>
        /// Editor update.
        /// </summary>
        private void Update()
        {
            if (!_isLoaded)
            {
                LoadAllSbsarFiles();
                _isLoaded = true;
            }

            _managedInstances.RemoveAll(item => item == null);

            HandleDelayedInitialization();
            HandlePlaymode();
            CheckUIUpdate();
            CheckRenderResultsUpdates();
        }

        private void HandleDelayedInitialization()
        {
            while (_delayiedInitilization.Count != 0)
            {
                var instancePath = _delayiedInitilization.Dequeue();
                var materialInstance = AssetDatabase.LoadAssetAtPath<SubstanceGraphSO>(instancePath);
                _managedInstances.Add(materialInstance);
            }
        }

        private bool _onPlaymodeEnterHandled = false;

        private void HandlePlaymode()
        {
            if (EditorApplication.isPlaying && !_onPlaymodeEnterHandled)
            {
                var runtiemMaterials = GameObject.FindObjectsOfType<Substance.Runtime.SubstanceRuntimeGraph>();

                foreach (var graph in _managedInstances)
                {
                    bool isAssigned = runtiemMaterials.FirstOrDefault(a => a.GraphSO == graph) != null;

                    if (Application.IsPlaying(graph) && (isAssigned || graph.IsRuntimeOnly))
                    {
                        if (!_playmodeObjects.Contains(graph))
                            _playmodeObjects.Add(graph);
                    }
                }

                _onPlaymodeEnterHandled = true;
            }

            if (!EditorApplication.isPlaying && _onPlaymodeEnterHandled)
            {
                var objectsToRemove = new List<SubstanceGraphSO>();

                foreach (var playmodeObject in _playmodeObjects)
                {
                    if (!Application.IsPlaying(playmodeObject))
                    {
                        playmodeObject.RenderTextures = true;
                        objectsToRemove.Add(playmodeObject);
                    }
                }

                foreach (var item in objectsToRemove)
                    _playmodeObjects.Remove(item);

                _onPlaymodeEnterHandled = false;
            }
        }

        /// <summary>
        /// Updated the state of the SubstanceFileHandlers based on changes made in the graph objects.
        /// </summary>
        private void CheckUIUpdate()
        {
            foreach (var graph in _managedInstances)
            {
                if (graph == null)
                    continue;

                if (graph.RawData == null)
                {
                    var assets = AssetDatabase.LoadAllAssetsAtPath(graph.AssetPath);

                    if (assets == null)
                        continue;

                    var dataObject = assets.FirstOrDefault(a => a is SubstanceFileRawData) as SubstanceFileRawData;

                    graph.RawData = dataObject;
                    EditorUtility.SetDirty(graph);
                    AssetDatabase.Refresh();
                }

                if (!TryGetHandlerFromInstance(graph, out SubstanceNativeHandler substanceHandler))
                    continue;

                if (substanceHandler.InRenderWork)
                    continue;

                if (graph.IsRuntimeOnly && graph.OutputMaterial != null)
                    if (graph.OutputMaterial.GetTexture("_MainTex") == null)
                        MaterialUtils.AssignOutputTexturesToMaterial(graph);

                if (HasMaterialShaderChanged(graph))
                {
                    SubmitAsyncRenderWork(substanceHandler, graph, true);
                    graph.RenderTextures = true;
                    continue;
                }

                if (graph.OutputRemaped)
                {
                    graph.OutputRemaped = false;

                    if (graph.IsRuntimeOnly)
                    {
                        DeleteGeneratedTextures(graph);
                    }

                    RenderingUtils.UpdateAlphaChannelsAssignment(substanceHandler, graph);
                    SubmitAsyncRenderWork(substanceHandler, graph, true);
                    graph.RenderTextures = true;
                    continue;
                }

                if (graph.RenderTextures)
                {
                    graph.RenderTextures = false;

                    if (_resetAllInputs)
                    {
                        _resetAllInputs = true;

                        foreach (var input in graph.Input)
                        {
                            input.UpdateNativeHandle(substanceHandler);
                        }
                    }

                    SubmitAsyncRenderWork(substanceHandler, graph);

                    EditorUtility.SetDirty(graph);
                }
            }
        }

        /// <summary>
        /// Updated the render results that are finished by the substance engine
        /// </summary>
        private void CheckRenderResultsUpdates()
        {
            if (_renderResultsQueue.TryDequeue(out RenderResult renderResult))
            {
                SubstanceGraphSO graph = _managedInstances.FirstOrDefault(a => a.GUID == renderResult.GUID && a.Index == renderResult.GraphID);

                if (graph == null)
                    return;

                if (!TryGetHandlerFromInstance(graph, out SubstanceNativeHandler handler))
                    return;

                var textureReassigned = UpdateTextureFromGraphRender(renderResult, graph, handler);

                if (textureReassigned)
                {
                    if (!string.IsNullOrEmpty(graph.AssetPath))
                    {
                        AssetCreationUtils.CreateMaterialOrUpdateMaterial(graph, graph.Name);
                        EditorUtility.SetDirty(graph);
                        EditorUtility.SetDirty(graph.OutputMaterial);
                        AssetDatabase.Refresh();
                    }
                }
                else
                {
                    if (graph.OutputMaterial == null)
                    {
                        AssetCreationUtils.CreateMaterialOrUpdateMaterial(graph, graph.Name);
                        EditorUtility.SetDirty(graph);
                        EditorUtility.SetDirty(graph.OutputMaterial);
                        AssetDatabase.Refresh();
                    }
                    else
                    {
                        EditorUtility.SetDirty(graph.OutputMaterial);
                    }
                }

                handler.InRenderWork = false;
            }
        }

        /// <summary>
        /// Checks if the shaders assigned to the substance graph generated material has changed. If so, we have to change the default outputs.
        /// </summary>
        private bool HasMaterialShaderChanged(SubstanceGraphSO graph)
        {
            if (graph.OutputMaterial == null || string.IsNullOrEmpty(graph.MaterialShader))
                return false;

            if (graph.OutputMaterial.shader.name == graph.MaterialShader)
                return false;

            AssetCreationUtils.UpdateMeterialAssignment(graph);
            return true;
        }

        #endregion Update

        #region Public methods

        #region Instance Management

        internal void InitializeSubstanceFile(string assetPath, out int graphCount, out string guid)
        {
            var substanceArchive = Engine.OpenFile(assetPath);
            graphCount = substanceArchive.GetGraphCount();
            guid = System.Guid.NewGuid().ToString();
            _activeSubstanceDictionary.Add(guid, substanceArchive);
        }

        /// <summary>
        /// Loads a sbsar file into the engine. The engine will keep track of this file internally.
        /// </summary>
        /// <param name="assetPath">Path to a sbsar file.</param>
        public void InitializeInstance(SubstanceGraphSO substanceInstance, string instancePath)
        {
            if (substanceInstance == null)
                return;

            if (string.IsNullOrEmpty(substanceInstance.AssetPath))
                Debug.LogError("Unable to instantiate substance material with null assetPath.");

            if (!_activeSubstanceDictionary.TryGetValue(substanceInstance.GUID, out SubstanceNativeHandler _))
            {
                var substanceArchive = Engine.OpenFile(substanceInstance.AssetPath);
                _activeSubstanceDictionary.Add(substanceInstance.GUID, substanceArchive);
            }

            if (!string.IsNullOrEmpty(instancePath))
                _delayiedInitilization.Enqueue(instancePath);
            else
            {
                _managedInstances.Add(substanceInstance);
            }
        }

        /// <summary>
        /// Unloads the target substance from th e substance engine.
        /// </summary>
        /// <param name="assetPath">Path to a sbsar file.</param>
        public void ReleaseInstance(SubstanceGraphSO substanceInstance)
        {
            if (TryGetHandlerFromInstance(substanceInstance, out SubstanceNativeHandler substanceArchive))
            {
                _activeSubstanceDictionary.Remove(substanceInstance.GUID);
                substanceArchive.Dispose();

                var managedInstance = _managedInstances.FirstOrDefault((a) => a.GUID == substanceInstance.GUID);

                if (managedInstance != null)
                    _managedInstances.Remove(managedInstance);
            }
        }

        #endregion Instance Management

        public void PushAllInputsToUpdate()
        {
            _resetAllInputs = true;
        }

        /// <summary>
        /// Loads the list of substance graphs from a substance file.
        /// </summary>
        /// <param name="assetPath">Path to the target substance file.</param>
        /// <returns>List of substance graph objects.</returns>
        public void CreateGraphObject(SubstanceGraphSO instance, SubstanceGraphSO copy = null)
        {
            if (!TryGetHandlerFromInstance(instance, out SubstanceNativeHandler substanceHandle))
                return;

            if (copy != null)
            {
                if (TryGetHandlerFromInstance(copy, out SubstanceNativeHandler copyHandle))
                {
                    var copyPreset = copyHandle.CreatePresetFromCurrentState(copy.Index);
                    substanceHandle.ApplyPreset(instance.Index, copyPreset); ;
                }
            }

            instance.Input = GetGraphInputs(substanceHandle, instance.Index);
            instance.Output = GetGraphOutputs(substanceHandle, instance.Index);
            instance.PhysicalSize = substanceHandle.GetPhysicalSize(instance.Index);
            instance.HasPhysicalSize = instance.PhysicalSize != Vector3.zero;

            RenderingUtils.ConfigureOutputTextures(substanceHandle, instance);

            instance.GenerateAllOutputs = SubstanceEditorSettingsSO.GenerateAllTextures();
            SetOutputTextureSize(instance, substanceHandle);

            instance.DefaultPreset = substanceHandle.CreatePresetFromCurrentState(instance.Index);

            var thumbnailData = substanceHandle.GetThumbnail(instance.Index);

            if (thumbnailData != null)
            {
                instance.Thumbnail = thumbnailData;
                instance.HasThumbnail = true;
            }
        }

        /// <summary>
        /// Renders a substance file using the substance engine.
        /// </summary>
        /// <param name="assetPath">Path to a sbsar file.</param>
        /// <param name="graphID">Target graph index.</param>
        /// <returns>Task that will be finished once the rendering is finished.</returns>
        public Task RenderInstanceAsync(SubstanceGraphSO instances)
        {
            if (TryGetHandlerFromInstance(instances, out SubstanceNativeHandler substanceArchive))
                return SubmitAsyncRenderWork(substanceArchive, instances);

            return Task.CompletedTask;
        }

        public Task RenderInstanceAsync(IReadOnlyList<SubstanceGraphSO> instances)
        {
            if (TryGetHandlerFromInstance(instances.First(), out SubstanceNativeHandler substanceArchive))
                return SubmitAsyncRenderWork(substanceArchive, instances);

            return Task.CompletedTask;
        }

        /// <summary>
        /// Assigns the substance graph objects inputs to the substance file Handlers associated with them.
        /// </summary>
        /// <param name="assetPath">Path to the sbsar object.</param>
        /// <param name="graphCopy">List of graph objects.</param>
        internal void SetSubstanceInput(SubstanceGraphSO instance)
        {
            if (TryGetHandlerFromInstance(instance, out SubstanceNativeHandler substanceArchive))
            {
                foreach (var input in instance.Input)
                    input.UpdateNativeHandle(substanceArchive);
            }
        }

        #region Preset

        /// <summary>
        /// Get the preset XML document for the current state of the a managed substance object.
        /// </summary>
        /// <param name="assetPath">Path to the target sbsar file.</param>
        /// <param name="graphID">Target graph id. </param>
        /// <returns>XML document with the current input states as a preset. </returns>
        public string ExportGraphPresetXML(SubstanceGraphSO instance, int graphID)
        {
            if (!TryGetHandlerFromInstance(instance, out SubstanceNativeHandler substanceArchive))
                return null;

            return substanceArchive.CreatePresetFromCurrentState(graphID);
        }

        /// <summary>
        /// Loads the inputs from a preset XML document into the target graph of a managed substance file.
        /// </summary>
        /// <param name="substanceInstancePath">Path to the target sbsar file.</param>
        /// <param name="graphID">Target graph id.</param>
        /// <param name="presetXML">Preset XML document.</param>
        public void LoadPresetsToGraph(SubstanceGraphSO instance, string presetXML)
        {
            if (TryGetHandlerFromInstance(instance, out SubstanceNativeHandler substanceHandler))
            {
                substanceHandler.ApplyPreset(instance.Index, presetXML);

                instance.Input = GetGraphInputs(substanceHandler, instance.Index);
                instance.RenderTextures = true;
                EditorUtility.SetDirty(instance);
            }
        }

        #endregion Preset

        #endregion Public methods

        public bool TryGetHandlerFromInstance(SubstanceGraphSO substanceInstance, out SubstanceNativeHandler substanceHandler)
        {
            substanceHandler = null;

            if (substanceInstance == null)
                return false;

            if (!_activeSubstanceDictionary.TryGetValue(substanceInstance.GUID, out substanceHandler))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Loads all sbsar files currently in the project.
        /// </summary>
        private void LoadAllSbsarFiles()
        {
            string[] files = Directory.GetFiles(Application.dataPath, "*.sbsar", SearchOption.AllDirectories);

            foreach (string filePath in files)
            {
                if (filePath.StartsWith(Application.dataPath))
                {
                    var assetPath = "Assets" + filePath.Substring(Application.dataPath.Length);
                    assetPath = assetPath.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);

                    if (!File.Exists(assetPath))
                        continue;

                    SubstanceImporter importer = AssetImporter.GetAtPath(assetPath) as SubstanceImporter;

                    if (importer == null)
                        continue;

                    foreach (var substanceInstance in importer._instancesCopy)
                    {
                        if (!substanceInstance.IsRuntimeOnly)
                            return;

                        InitializeInstance(substanceInstance, AssetDatabase.GetAssetPath(substanceInstance));

                        if (TryGetHandlerFromInstance(substanceInstance, out SubstanceNativeHandler fileHandler))
                        {
                            if (substanceInstance == null)
                                continue;

                            substanceInstance.RuntimeInitialize(fileHandler, substanceInstance.IsRuntimeOnly);
                        }
                    }
                }
            }
        }

        public void RefreshActiveInstances()
        {
            foreach (var substanceInstance in _managedInstances)
            {
                substanceInstance.RenderTextures = true;
            }
        }

        private List<ISubstanceInput> GetGraphInputs(SubstanceNativeHandler substanceFileHandler, int graphID)
        {
            var inputs = new List<ISubstanceInput>();

            var graphInputCount = substanceFileHandler.GetInputCount(graphID);

            for (int j = 0; j < graphInputCount; j++)
            {
                SubstanceInputBase graphInput = substanceFileHandler.GetInputObject(graphID, j);
                inputs.Add(graphInput);
            }

            return inputs;
        }

        private List<SubstanceOutputTexture> GetGraphOutputs(SubstanceNativeHandler substanceFileHandler, int graphID)
        {
            var outputs = new List<SubstanceOutputTexture>();

            var graphOutputCount = substanceFileHandler.GetGraphOutputCount(graphID);

            for (int j = 0; j < graphOutputCount; j++)
            {
                var outputDescription = substanceFileHandler.GetOutputDescription(graphID, j);
                bool isStandard = MaterialUtils.CheckIfStandardOutput(outputDescription);
                SubstanceOutputTexture graphData = new SubstanceOutputTexture(outputDescription, graphID, isStandard);

                if (graphData.IsBaseColor() ||
                    graphData.IsDiffuse() ||
                    graphData.IsSpecular() ||
                    graphData.IsHightMap() ||
                    graphData.IsEmissive())
                {
                    graphData.sRGB = true;
                }
                else
                {
                    graphData.sRGB = false;
                }

                outputs.Add(graphData);
            }

            var diffuseOutput = outputs.FirstOrDefault(a => a.IsDiffuse());
            var baseColorOutput = outputs.FirstOrDefault(a => a.IsBaseColor());

            if (baseColorOutput == null && diffuseOutput != null)
                diffuseOutput.IsStandardOutput = true;

            return outputs;
        }

        private void SetOutputTextureSize(SubstanceGraphSO graph, SubstanceNativeHandler substanceFileHandler)
        {
            var outputSize = graph.Input.FirstOrDefault(a => a.Description.Label == "$outputsize");

            if (outputSize == null)
                return;

            if (outputSize is SubstanceInputInt2 outputSizeInput)
            {
                outputSizeInput.Data = SubstanceEditorSettingsSO.TextureOutputResultion();
                outputSizeInput.UpdateNativeHandle(substanceFileHandler);
            }
        }

        #region Rendering

        public Task SubmitAsyncRenderWork(SubstanceNativeHandler substanceArchive, SubstanceGraphSO instanceKey, bool forceRebuild = false)
        {
            if (substanceArchive.InRenderWork)
                return Task.CompletedTask;

            substanceArchive.InRenderWork = true;

            var renderResut = new RenderResult()
            {
                SubstanceArchive = substanceArchive,
                ForceRebuild = forceRebuild,
                GUID = instanceKey.GUID,
                GraphID = instanceKey.Index
            };

            return Task.Run(() =>
            {
                try
                {
                    renderResut.Result = substanceArchive.Render(instanceKey.Index);
                    _renderResultsQueue.Enqueue(renderResut);
                }
                catch (Exception e)
                {
                    substanceArchive.InRenderWork = false;
                    Debug.LogException(e);
                }
            });
        }

        private Task SubmitAsyncRenderWork(SubstanceNativeHandler substanceArchive, IReadOnlyList<SubstanceGraphSO> graphs, bool forceRebuild = false)
        {
            if (substanceArchive.InRenderWork)
                return Task.CompletedTask;

            substanceArchive.InRenderWork = true;

            foreach (var graph in graphs)
            {
                graph.CurrentStatePreset = substanceArchive.CreatePresetFromCurrentState(graph.Index);
                EditorUtility.SetDirty(graph);
            }

            return Task.Run(() =>
            {
                try
                {
                    foreach (var graph in graphs)
                    {
                        var renderResut = new RenderResult()
                        {
                            SubstanceArchive = substanceArchive,
                            ForceRebuild = forceRebuild,
                            GUID = graph.GUID,
                            GraphID = graph.Index
                        };

                        renderResut.Result = substanceArchive.Render(graph.Index);
                        _renderResultsQueue.Enqueue(renderResut);
                    }
                }
                catch (Exception e)
                {
                    substanceArchive.InRenderWork = false;
                    Debug.LogException(e);
                }
            });
        }

        /// <summary>
        /// Generate the .tga file from a RenderResult.
        /// </summary>
        /// <param name="renderResult">Target render result.</param>
        /// <param name="substance">Owner substance.</param>
        /// <returns>Returns true if textures must be reassigned to the material.</returns>
        private bool UpdateTextureFromGraphRender(RenderResult renderResult, SubstanceGraphSO graph, SubstanceNativeHandler handler)
        {
            if (!renderResult.ForceRebuild && CheckIfTextureAssetsExist(graph))
            {
                UpdateExistingTextures(renderResult, graph);
                return false;
            }

            graph.CreateAndUpdateOutputTextures(renderResult.Result, handler);

            if (graph.IsRuntimeOnly)
                return true;

            foreach (var substanceOutput in graph.Output)
            {
                var texture = substanceOutput.OutputTexture;

                if (texture == null)
                    continue;

                var textureOutput = graph.GetAssociatedAssetPath(substanceOutput.Description.Identifier, "tga");
                var bytes = texture.EncodeToTGA();
                File.WriteAllBytes(textureOutput, bytes);
            }

            AssetDatabase.Refresh();

            foreach (var substanceOutput in graph.Output)
            {
                var texture = substanceOutput.OutputTexture;

                if (texture == null)
                    continue;

                var textureOutput = graph.GetAssociatedAssetPath(substanceOutput.Description.Identifier, "tga");
                substanceOutput.OutputTexture = AssetDatabase.LoadAssetAtPath<Texture2D>(textureOutput);
                ConfigureTextureImporter(substanceOutput);
            }

            AssetDatabase.Refresh();
            return true;
        }

        private void UpdateExistingTextures(RenderResult renderResult, SubstanceGraphSO graph)
        {
            var renderResultsSizes = graph.GetResizedOutputs(renderResult.Result);

            //Resize existing output textures.
            if (renderResultsSizes.Count != 0)
            {
                foreach (var resultSize in renderResultsSizes)
                {
                    var outputIndex = resultSize.Item1;
                    var outputSize = resultSize.Item2;
                    var targetOutput = graph.Output.FirstOrDefault(a => a.Index == outputIndex);

#if UNITY_2021_2_OR_NEWER
                    targetOutput.OutputTexture.Reinitialize(outputSize.x, outputSize.y);
#else
                    targetOutput.OutputTexture.Resize(outputSize.x, outputSize.y);
#endif
                    if (!graph.IsRuntimeOnly)
                    {
                        var bytes = targetOutput.OutputTexture.EncodeToTGA();
                        var assetPath = AssetDatabase.GetAssetPath(targetOutput.OutputTexture);
                        File.WriteAllBytes(assetPath, bytes);
                    }
                }

                AssetDatabase.Refresh();
            }

            graph.UpdateOutputTextures(renderResult.Result);
        }

        /// <summary>
        /// Try to get the texture2D instances for a give graph.
        /// </summary>
        /// <param name="graph">Target graph.</param>
        /// <param name="textures">Array of texture2D instances attached to each substance output.</param>
        /// <returns>True if all textures instances exists. If false they must be rebuild.</returns>
        private bool CheckIfTextureAssetsExist(SubstanceGraphSO graph)
        {
            foreach (var output in graph.Output)
            {
                if (!output.IsStandardOutput && !graph.GenerateAllOutputs)
                {
                    if (output.OutputTexture != null)
                    {
                        var assetPath = AssetDatabase.GetAssetPath(output.OutputTexture);

                        if (!string.IsNullOrEmpty(assetPath))
                            AssetDatabase.DeleteAsset(assetPath);

                        output.OutputTexture = null;
                    }

                    continue;
                }

                if (output.OutputTexture == null)
                    return false;

                output.OutputTexture = TextureUtils.EnsureTextureCorrectness(output.OutputTexture, !output.IsNormalMap(), graph.GenerateAllMipmaps);
            }

            return true;
        }

        /// <summary>
        /// Configures the texture importer settings to the associated texture output.
        /// </summary>
        /// <param name="textureOutput">Target output texture.</param>
        private void ConfigureTextureImporter(SubstanceOutputTexture textureOutput)
        {
            var texturePath = AssetDatabase.GetAssetPath(textureOutput.OutputTexture);
            TextureImporter importer = AssetImporter.GetAtPath(texturePath) as TextureImporter;

            if (importer == null)
                return;

            importer.textureCompression = TextureImporterCompression.Uncompressed;
            importer.isReadable = true;
            importer.maxTextureSize = 4096;
            importer.sRGBTexture = textureOutput.sRGB;

            if (textureOutput.IsNormalMap())
            {
                importer.textureType = TextureImporterType.NormalMap;
            }
            else
            {
                var defaultSettings = importer.GetDefaultPlatformTextureSettings();

                if (defaultSettings.format != TextureImporterFormat.RGBA32)
                {
                    defaultSettings.format = TextureImporterFormat.RGBA32;
                    importer.SetPlatformTextureSettings(defaultSettings);
                }
            }

            EditorUtility.SetDirty(importer);
            AssetDatabase.WriteImportSettingsIfDirty(texturePath);
        }

        private void DeleteGeneratedTextures(SubstanceGraphSO graph)
        {
            foreach (var output in graph.Output)
            {
                if (output.OutputTexture != null)
                {
                    var texturePath = AssetDatabase.GetAssetPath(output.OutputTexture);

                    if (!string.IsNullOrEmpty(texturePath))
                        AssetDatabase.DeleteAsset(texturePath);
                }
            }
        }

        private struct RenderResult
        {
            public SubstanceNativeHandler SubstanceArchive;
            public IntPtr Result;
            public bool ForceRebuild;
            public string GUID;
            public int GraphID;
        }

        #endregion Rendering
    }
}